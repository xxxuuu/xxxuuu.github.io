<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>ä» Linux å†…æ ¸çœ‹è¯»å†™é”è®¾è®¡ | xÂ³uÂ³</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css">
<link rel="shortcut icon" href="https://xxxuuu.me/favicon.ico?v=1723216798723">
<link rel="stylesheet" href="https://xxxuuu.me/styles/main.css">



<link href="https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css" rel="stylesheet">
<style>
:root {
  --animate-duration: 800ms;
}
</style>
<script src="https://cdn.jsdelivr.net/npm/vue@2.6.9/dist/vue.min.js"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-T8WGT1LJ6G"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-T8WGT1LJ6G');
</script>


    <meta name="description" content="å‰æ®µæ—¶é—´çœ‹äº†ã€ŠLinuxå†…æ ¸è®¾è®¡ä¸å®ç°ã€‹ï¼Œç¬¬ 10 ç« ã€Œå†…æ ¸åŒæ­¥æ–¹æ³•ã€ä¸­æåˆ°äº†å‡ ç§å†…æ ¸ä¸­çš„è¯»å†™é”ã€‚å®ƒä»¬åˆ†åˆ«ä»£è¡¨äº†å‡ ç§æ¯”è¾ƒå…¸å‹çš„è¯»å†™é”è®¾è®¡ï¼Œéå¸¸å€¼å¾—å­¦ä¹ ï¼Œè¿™é‡Œè®°å½•ä¸€ä¸‹ï¼Œè®¨è®ºæ˜¯åŸºäº 2.6 å†…æ ¸å’Œ x86 ä½“ç³»ç»“æ„çš„åŸºç¡€ä¸Šè¿›è¡Œçš„

è¯»/å†™è‡ªæ—‹é”..." />
    <meta name="keywords" content="Linux,å†…æ ¸" />
    
      <link href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css" rel="stylesheet">
      <script src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" rel="stylesheet">
  </head>
  <body>
    <div id="app" class="main">

      <header class="header">
  <div class="banner animate__animated animate__fadeIn">
    <div class="top-container">
      <div class="site-title-container">
        <img src="https://xxxuuu.me/images/avatar.png?v=1723216798723" class="site-logo">
        <div class="site-text">
          <h1 class="site-title">
            xÂ³uÂ³
          </h1>
          <div class="site-description-social">
            <div class="site-description">
              ğŸ—’ ç¢ç¢å¿µ
            </div>
            <div class="site-social">
              
                
                  <a class="social-link" href="https://github.com/xxxuuu" target="_blank">
                    <i class="fa fa-github"></i>
                  </a>
                
              
                
              
                
              
                
              
                
              
            </div>
          </div>
        </div>
      </div>
    </div>
    <div class="links">
      
        
            <a href="/" class="site-nav">
              ğŸ  é¦–é¡µ
            </a>
          
        
        
            <a href="/archives" class="site-nav">
              ğŸ“ƒ å½’æ¡£
            </a>
          
        
        
            <a href="/tags" class="site-nav">
              ğŸ· æ ‡ç­¾
            </a>
          
        
        
            <a href="/post/about" class="site-nav">
              ğŸ‘¤ å…³äº
            </a>
          
        
        
            <a href="/post/friend-links/" class="site-nav">
              ğŸ‘¬ å‹é“¾
            </a>
          
        
    </div>
  </div>
</header>

      <div class="main-container">
        <div class="content-container animate__animated animate__fadeInUp">
          <div class="post-detail">
            <h2 class="post-title">ä» Linux å†…æ ¸çœ‹è¯»å†™é”è®¾è®¡</h2>
            <div class="post-date">2024-01-04&emsp;&emsp;3143 å­— &emsp;é˜…è¯»æ—¶é—´ 16 åˆ†é’Ÿ</div>
            
            <div class="post-content" v-pre>
              <p>å‰æ®µæ—¶é—´çœ‹äº†ã€ŠLinuxå†…æ ¸è®¾è®¡ä¸å®ç°ã€‹ï¼Œç¬¬ 10 ç« ã€Œå†…æ ¸åŒæ­¥æ–¹æ³•ã€ä¸­æåˆ°äº†å‡ ç§å†…æ ¸ä¸­çš„è¯»å†™é”ã€‚å®ƒä»¬åˆ†åˆ«ä»£è¡¨äº†å‡ ç§æ¯”è¾ƒå…¸å‹çš„è¯»å†™é”è®¾è®¡ï¼Œéå¸¸å€¼å¾—å­¦ä¹ ï¼Œè¿™é‡Œè®°å½•ä¸€ä¸‹ï¼Œè®¨è®ºæ˜¯åŸºäº 2.6 å†…æ ¸å’Œ x86 ä½“ç³»ç»“æ„çš„åŸºç¡€ä¸Šè¿›è¡Œçš„</p>
<!-- more -->
<h2 id="è¯»å†™è‡ªæ—‹é”">è¯»/å†™è‡ªæ—‹é”</h2>
<p>å†…æ ¸ä»£ç ä¸­ï¼Œè¦å®šä¹‰è¯»/å†™è‡ªæ—‹é”ï¼Œé€šè¿‡ä¸‹é¢çš„å®è¿›è¡Œåˆå§‹åŒ–ï¼š</p>
<pre><code class="language-C">DEFINE_RWLOCK(mr_rwlock);
</code></pre>
<p>ä½¿ç”¨ä¸Šè¯»é”å’Œå†™é”æ˜¯åˆ†å¼€åŠ é”çš„</p>
<pre><code class="language-C">read_lock(&amp;mr_rwlock);
// åªè¯»ä¸´ç•ŒåŒº
read_unlock(&amp;mr_rwlock);

write_lock(&amp;mr_rwlock);
// è¯»å†™ä¸´ç•ŒåŒº
write_unlock(&amp;mr_rwlock);
</code></pre>
<p><strong>ä¸èƒ½</strong>åƒè¿™æ ·å°†ä¸€ä¸ªè¯»é”å‡çº§æˆå†™é”ï¼Œè¿™ä¼šå¯¼è‡´æ­»é”ï¼›å¹¶ä¸”å†™é”ä¹Ÿæ˜¯ä¸å¯é‡å…¥çš„ï¼š</p>
<pre><code class="language-C">read_lock(&amp;mr_rwlock);
write_lock(&amp;mr_rwlock);
</code></pre>
<p>è¯»/å†™è‡ªæ—‹é”çš„æ±‡ç¼–çº§åˆ«å®ç°æ¯”è¾ƒç±»ä¼¼ä¿¡å·é‡ï¼Œéƒ½æ˜¯åœ¨å¯„å­˜å™¨ä¸Šå¯¹å€¼åšå¢å‡ï¼Œä½†ä¸ºäº†åŒºåˆ†è¯»é”å’Œå†™é”ï¼Œè¯»é”æ˜¯å›ºå®šå‡ 1ï¼Œå†™é”åˆ™æ˜¯å›ºå®šå‡å»ä¸€ä¸ªå¾ˆå¤§çš„ magic numberï¼Œé€šè¿‡ç»“æœå€¼æ¯”è¾ƒå°±èƒ½åˆ¤æ–­é”æŒæœ‰æƒ…å†µ</p>
<p>ä»£ç åˆ†åˆ«ä½äº <a href="https://elixir.bootlin.com/linux/v2.6.0/source/include/asm-x86_64/rwlock.h">include/asm-x86_64/rwlock.h</a> å’Œ <a href="https://elixir.bootlin.com/linux/v2.6.0/source/include/asm-x86_64/spinlock.h">/include/asm-x86_64/spinlock.h</a> ä¸­ï¼Œè¿™ä¸¤å—æ¶‰åŠçš„æ ¸å¿ƒä»£ç èåˆä¸€ä¸‹å¤§è‡´å¦‚ä¸‹ï¼š</p>
<pre><code class="language-C">#define RW_LOCK_BIAS 0x01000000

// åˆå§‹åŒ–æ—¶è®¾ç½®è¿™ä¸ªå€¼ä¸º magic number
#define rwlock_init(x)	do { *(x) = RW_LOCK_UNLOCKED; } while(0)

// è·å–è¯»é”
// å°†eaxå¯„å­˜å™¨æŒ‡å‘çš„åœ°å€ï¼Œä¹Ÿå°±æ˜¯å˜é‡rwçš„å€¼å‡1ï¼ˆsubl $1ï¼‰
// æ ¹æ®ç»“æœæ˜¯å¦å°äº0ï¼ˆjs 2fï¼‰åšè·³è½¬ï¼Œå°äº0å°±å»è°ƒç”¨ä¼ å…¥çš„helperåšè·å–å¤±è´¥çš„å¤„ç†
// æ²¡æœ‰å†™é”çš„æƒ…å†µä¸‹æ˜¯ä¸ä¼šå°äº0çš„ï¼Œä¸å¯èƒ½æœ‰è¿™ä¹ˆå¤šè¯»è€…èƒ½è®©å®ƒå‡åˆ°0ï¼Œæ‰€ä»¥ä¸å°äº0å°±æ˜¯è·å–æˆåŠŸ
#define __build_read_lock_ptr(rw, helper)   \
	asm volatile(LOCK &quot;subl $1,(%0)\n\t&quot; \ 
		     &quot;js 2f\n&quot; \ 
		     &quot;1:\n&quot; \
		    LOCK_SECTION_START(&quot;&quot;) \
		     &quot;2:\tcall &quot; helper &quot;\n\t&quot; \
		     &quot;jmp 1b\n&quot; \
		    LOCK_SECTION_END \
		     ::&quot;a&quot; (rw) : &quot;memory&quot;)

// ä¼ å…¥çš„helperä½äºarch/i386/kernel/semaphore.c
// è¿™é‡Œå°±æ˜¯ä¸€ä¸ªè‡ªæ—‹çš„é€»è¾‘ï¼ŒæŒç»­æ“ä½œrwç›´åˆ°å®ƒæ˜¯å¤§äºç­‰äº0çš„ï¼Œç›¸å½“äº:
// 
// lock_failed:
// rw++;
// while(rw &lt; 1) {}
// rw--;
// if(rw &lt; 0) goto lock_failed;
// 
// è¿™é‡Œç»“å°¾è¿˜è¦åˆ¤æ–­ä¸€æ¬¡ï¼Œæ˜¯å› ä¸ºå‰é¢çš„æ“ä½œæ•´ä½“ä¸Šä¸æ˜¯åŸå­æˆ–äº’æ–¥çš„ï¼Œæ‰€ä»¥declåè¦å†checkä¸€ä¸‹
asm(
&quot;.text\n&quot;
&quot;.align	4\n&quot;
&quot;.globl	__read_lock_failed\n&quot;
&quot;__read_lock_failed:\n\t&quot;
	LOCK &quot;incl	(%eax)\n&quot;
&quot;1:	rep; nop\n\t&quot;
	&quot;cmpl	$1,(%eax)\n\t&quot;
	&quot;js	1b\n\t&quot;
	LOCK &quot;decl	(%eax)\n\t&quot;
	&quot;js	__read_lock_failed\n\t&quot;
	&quot;ret&quot;
);

// è·å–å†™é”
// eaxå¯„å­˜å™¨æŒ‡å‘çš„åœ°å€å€¼ï¼Œä¹Ÿå°±æ˜¯rwå‡å»magic number
// åˆ¤æ–­ç»“æœæ˜¯å¦åˆšå¥½ä¸º0ï¼ˆjnz 2fï¼‰ï¼Œä¸æ˜¯åˆ™è¯´æ˜æœ‰è¯»é”åœ¨å ç”¨ï¼Œè·³è½¬åˆ°helperè°ƒç”¨
#define __build_write_lock_ptr(rw, helper) \
	asm volatile(LOCK &quot;subl $&quot; RW_LOCK_BIAS_STR &quot;,(%0)\n\t&quot; \
		     &quot;jnz 2f\n&quot; \
		     &quot;1:\n&quot; \
		     LOCK_SECTION_START(&quot;&quot;) \
		     &quot;2:\tcall &quot; helper &quot;\n\t&quot; \
		     &quot;jmp 1b\n&quot; \
		     LOCK_SECTION_END \
		     ::&quot;a&quot; (rw) : &quot;memory&quot;)

// å†™é”ä¼ å…¥çš„helperåŒæ ·ä½äºarch/i386/kernel/semaphore.c
// é€»è¾‘å’Œè¯»é”çš„åŸºæœ¬ä¸€æ ·
asm(
&quot;.text\n&quot;
&quot;.align	4\n&quot;
&quot;.globl	__write_lock_failed\n&quot;
&quot;__write_lock_failed:\n\t&quot;
	LOCK &quot;addl	$&quot; RW_LOCK_BIAS_STR &quot;,(%eax)\n&quot;
&quot;1:	rep; nop\n\t&quot;
	&quot;cmpl	$&quot; RW_LOCK_BIAS_STR &quot;,(%eax)\n\t&quot;
	&quot;jne	1b\n\t&quot;
	LOCK &quot;subl	$&quot; RW_LOCK_BIAS_STR &quot;,(%eax)\n\t&quot;
	&quot;jnz	__write_lock_failed\n\t&quot;
	&quot;ret&quot;
);

// è§£é”æ—¶å°±æ˜¯åŠ ä¸Š1æˆ–magic number
#define _raw_read_unlock(rw) asm volatile(&quot;lock ; incl %0&quot; :&quot;=m&quot; ((rw)-&gt;lock) : : &quot;memory&quot;)
#define _raw_write_unlock(rw)	asm volatile(&quot;lock ; addl $&quot; RW_LOCK_BIAS_STR &quot;,%0&quot;:&quot;=m&quot; ((rw)-&gt;lock) : : &quot;memory&quot;)
</code></pre>
<p>å¯ä»¥çœ‹å‡ºï¼Œè¯»/å†™è‡ªæ—‹é”æ˜¯<strong>è¯»ä¼˜å…ˆ</strong>çš„ï¼Œä¼šå¯¼è‡´å†™é¥¥é¥¿ã€‚å½“æœ‰ä¸€ä¸ªæˆ–å¤šä¸ªè¯»è€…æŒæœ‰è¯»é”æ—¶ï¼Œå†™æ“ä½œæ— æ³•è·å–é”ï¼Œå¦‚æœæ­¤æ—¶è¯»é”è¢«é•¿æ—¶é—´å æœ‰ï¼Œå†™é”å°†ä¸€ç›´è‡ªæ—‹ç­‰å¾…ï¼Œæ­¤æ—¶è‡ªæ—‹ä¼šå¯¼è‡´ä¸€ä¸ªæ ¸å¿ƒä¸Šçš„é«˜æ˜‚å¼€é”€</p>
<p>è¿™é‡Œæœ‰ä¸€ä¸ªå¤„ç†ä¸Šçš„ç»†èŠ‚ï¼Œåœ¨çœŸæ­£å¼€å§‹è‡ªæ—‹è·å–åˆ°å†™é”ä¹‹å‰ï¼Œå°±å·²ç»äº’æ–¥äº†ï¼ˆå‡å» magic numberï¼‰ï¼Œè¿™æ—¶å€™æ–°çš„è¯»é”æ˜¯æ— æ³•è·å–çš„ï¼Œè¿™é¿å…äº†å†™é”å’Œè¯»é”çš„äº‰æŠ¢ï¼Œèƒ½ç¨å¾®ç¼“è§£ä¸‹å†™é¥¥é¥¿é—®é¢˜ï¼Œä¾‹å¦‚è¿™æ ·çš„æƒ…å†µï¼š</p>
<pre><code>                            TIME
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚    reader    â”‚
 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”‚   spin   â”‚       writer       â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
           â”‚           spin          â”‚     reader    â”‚
           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                        â”‚    spin    â”‚   reader  â”‚
                        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<h2 id="è¯»å†™ä¿¡å·é‡">è¯»/å†™ä¿¡å·é‡</h2>
<p>è¯»/å†™ä¿¡å·é‡çš„ä½¿ç”¨ä¸Šå’Œè¯»/å†™è‡ªæ—‹é”æ˜¯ç±»ä¼¼çš„ï¼Œä½†åŠŸèƒ½ä¸Šè¦å¼ºå¤§ä¸€äº›ï¼Œåˆ†åˆ«æ”¯æŒé™æ€å’ŒåŠ¨æ€çš„åˆå§‹åŒ–æ–¹æ³•</p>
<pre><code class="language-C">// é™æ€å®šä¹‰
static DECLARE_RWSEM(name);
// åŠ¨æ€å®šä¹‰
init_rwsem(struct rw_semaphore *sem);
</code></pre>
<p>è¯»/å†™ä¿¡å·é‡æ”¯æŒ trylock æ“ä½œå’ŒåŠ¨æ€åœ°å°†å†™é”é™çº§ä¸ºè¯»é”</p>
<pre><code class="language-C">static DECLARE_RWSEM(mr_rwsem);

down_read(&amp;mr_rwsem);
// åªè¯»ä¸´ç•ŒåŒº
up_read(&amp;mr_rwsem);

down_write(&amp;mr_rwsem);
// è¯»å†™ä¸´ç•ŒåŒº
up_write(&amp;mr_rwsem);

down_write(&amp;mr_rwsem);
// è¯»å†™ä¸´ç•ŒåŒº
downgrade_write(&amp;mr_rwsem); // å†™é”é™çº§è¯»é”
// åªè¯»ä¸´ç•ŒåŒº
up_read(&amp;mr_rwsem);
</code></pre>
<p><a href="https://elixir.bootlin.com/linux/v2.6.0/source/include/asm-x86_64/rwsem.h#L99">include/asm-x86_64/rwsem.h</a> ä¸­å®šä¹‰äº†æ±‡ç¼–çº§åˆ«ä¸Šçš„å®ç°ï¼Œå’Œå‰é¢è¯»/å†™è‡ªæ—‹é”æ˜¯ç±»ä¼¼çš„ï¼Œä½†æ²¡æœ‰è‡ªæ—‹ï¼Œè¿™é‡Œå°±ä¸ç»†è¯´ï¼Œå†…æ ¸æºç è¿™é‡Œä¹Ÿç›´æ¥é™„å¸¦æ³¨é‡Šäº†ï¼š</p>
<pre><code class="language-C">#define RWSEM_UNLOCKED_VALUE		  0x00000000
#define RWSEM_ACTIVE_BIAS		      0x00000001
#define RWSEM_ACTIVE_MASK		      0x0000ffff
#define RWSEM_WAITING_BIAS		    (-0x00010000)
#define RWSEM_ACTIVE_READ_BIAS		RWSEM_ACTIVE_BIAS
#define RWSEM_ACTIVE_WRITE_BIAS		(RWSEM_WAITING_BIAS + RWSEM_ACTIVE_BIAS)

/*
 * lock for reading
 */
static inline void __down_read(struct rw_semaphore *sem)
{
	__asm__ __volatile__(
		&quot;# beginning down_read\n\t&quot;
LOCK_PREFIX	&quot;  incl      (%%rdi)\n\t&quot; /* adds 0x00000001, returns the old value */
		&quot;  js        2f\n\t&quot; /* jump if we weren't granted the lock */
		&quot;1:\n\t&quot;
		LOCK_SECTION_START(&quot;&quot;) \
		&quot;2:\n\t&quot;
		&quot;  call      rwsem_down_read_failed_thunk\n\t&quot;
		&quot;  jmp       1b\n&quot;
		LOCK_SECTION_END \
		&quot;# ending down_read\n\t&quot;
		: &quot;+m&quot;(sem-&gt;count)
		: &quot;D&quot;(sem)
		: &quot;memory&quot;, &quot;cc&quot;);
}

/*
 * lock for writing
 */
static inline void __down_write(struct rw_semaphore *sem)
{
	int tmp;

	tmp = RWSEM_ACTIVE_WRITE_BIAS;
	__asm__ __volatile__(
		&quot;# beginning down_write\n\t&quot;
LOCK_PREFIX	&quot;  xaddl      %0,(%%rdi)\n\t&quot; /* subtract 0x0000ffff, returns the old value */
		&quot;  testl     %0,%0\n\t&quot; /* was the count 0 before? */
		&quot;  jnz       2f\n\t&quot; /* jump if we weren't granted the lock */
		&quot;1:\n\t&quot;
		LOCK_SECTION_START(&quot;&quot;)
		&quot;2:\n\t&quot;
		&quot;  call      rwsem_down_write_failed_thunk\n\t&quot;
		&quot;  jmp       1b\n&quot;
		LOCK_SECTION_END
		&quot;# ending down_write&quot;
		: &quot;=&amp;r&quot; (tmp) 
		: &quot;0&quot;(tmp), &quot;D&quot;(sem)
		: &quot;memory&quot;, &quot;cc&quot;);
}

/*
 * unlock after reading
 */
static inline void __up_read(struct rw_semaphore *sem)
{
	__s32 tmp = -RWSEM_ACTIVE_READ_BIAS;
	__asm__ __volatile__(
		&quot;# beginning __up_read\n\t&quot;
LOCK_PREFIX	&quot;  xaddl      %[tmp],(%%rdi)\n\t&quot; /* subtracts 1, returns the old value */
		&quot;  js        2f\n\t&quot; /* jump if the lock is being waited upon */
		&quot;1:\n\t&quot;
		LOCK_SECTION_START(&quot;&quot;)
		&quot;2:\n\t&quot;
		&quot;  decw      %w[tmp]\n\t&quot; /* do nothing if still outstanding active readers */
		&quot;  jnz       1b\n\t&quot;
		&quot;  call      rwsem_wake_thunk\n\t&quot;
		&quot;  jmp       1b\n&quot;
		LOCK_SECTION_END
		&quot;# ending __up_read\n&quot;
		: &quot;+m&quot;(sem-&gt;count), [tmp] &quot;+r&quot; (tmp)
		: &quot;D&quot;(sem)
		: &quot;memory&quot;, &quot;cc&quot;);
}

/*
 * unlock after writing
 */
static inline void __up_write(struct rw_semaphore *sem)
{
	unsigned tmp; 
	__asm__ __volatile__(
		&quot;# beginning __up_write\n\t&quot;
		&quot;  movl     %[bias],%[tmp]\n\t&quot;
LOCK_PREFIX	&quot;  xaddl     %[tmp],(%%rdi)\n\t&quot; /* tries to transition 0xffff0001 -&gt; 0x00000000 */
		&quot;  jnz       2f\n\t&quot; /* jump if the lock is being waited upon */
		&quot;1:\n\t&quot;
		LOCK_SECTION_START(&quot;&quot;)
		&quot;2:\n\t&quot;
		&quot;  decw      %w[tmp]\n\t&quot; /* did the active count reduce to 0? */
		&quot;  jnz       1b\n\t&quot; /* jump back if not */
		&quot;  call      rwsem_wake_thunk\n\t&quot;
		&quot;  jmp       1b\n&quot;
		LOCK_SECTION_END
		&quot;# ending __up_write\n&quot;
		: &quot;+m&quot;(sem-&gt;count), [tmp] &quot;=r&quot; (tmp)
		: &quot;D&quot;(sem), [bias] &quot;i&quot;(-RWSEM_ACTIVE_WRITE_BIAS)
		: &quot;memory&quot;, &quot;cc&quot;);
}
</code></pre>
<p>ä¿¡å·é‡æ˜¯ç¡çœ é”ï¼Œè¯»é”å’Œå†™é”åœ¨è·å–é”å¤±è´¥æ—¶æœ€åéƒ½ä¼šè¿›å…¥åˆ° <code>rwsem_down_failed_common</code>ï¼ˆä½äº <a href="https://elixir.bootlin.com/linux/v2.6.0/source/lib/rwsem.c#L123">lib/rwsem.c</a>ï¼‰ ä¸­ï¼Œè¿™é‡Œä¼šå°†è¿›ç¨‹åŠ å…¥ç­‰å¾…é˜Ÿåˆ—ä¸­ï¼Œç„¶åé‡æ–°è°ƒåº¦è¿›ç¨‹</p>
<pre><code class="language-C">static inline struct rw_semaphore *rwsem_down_failed_common(struct rw_semaphore *sem,
								 struct rwsem_waiter *waiter,
								 signed long adjustment)
{
	struct task_struct *tsk = current;
	signed long count;

	set_task_state(tsk,TASK_UNINTERRUPTIBLE);

	/* set up my own style of waitqueue */
	spin_lock(&amp;sem-&gt;wait_lock);
	waiter-&gt;task = tsk;

	list_add_tail(&amp;waiter-&gt;list,&amp;sem-&gt;wait_list);

	/* note that we're now waiting on the lock, but no longer actively read-locking */
	count = rwsem_atomic_update(adjustment,sem);

	/* if there are no longer active locks, wake the front queued process(es) up
	 * - it might even be this process, since the waker takes a more active part
	 */
	if (!(count &amp; RWSEM_ACTIVE_MASK))
		sem = __rwsem_do_wake(sem,1);

	spin_unlock(&amp;sem-&gt;wait_lock);

	/* wait to be given the lock */
	for (;;) {
		if (!waiter-&gt;flags)
			break;
		schedule();
		set_task_state(tsk, TASK_UNINTERRUPTIBLE);
	}

	tsk-&gt;state = TASK_RUNNING;

	return sem;
}
</code></pre>
<p>å€¼å¾—ä¸€æçš„æ˜¯ <code>trylock</code> å’Œ <code>downgrade_write</code> æ“ä½œï¼Œè¿™ä¸¤ä¸ªæ“ä½œæ˜¯è¯»/å†™è‡ªæ—‹é”ä¸­æ²¡æœ‰çš„</p>
<p>ä¸¤ä¸ª <code>trylock</code> æ˜¯ç±»ä¼¼çš„ï¼Œéƒ½æ˜¯ç”¨ <code>cmpxchg</code> æŒ‡ä»¤æ¥åš CASï¼ˆcompare-and-swapï¼‰ æ“ä½œã€‚å†™é”çš„ <code>trylock</code> æ¯”è¾ƒç®€å•ï¼Œå› ä¸ºæ˜¯äº’æ–¥çš„ï¼Œæ‰€ä»¥åªéœ€è¦å¯¹åˆå§‹å€¼åš CAS å³å¯ã€‚è€Œè¯»é”å¯èƒ½è¢«æŒæœ‰å¤šä¸ªï¼Œæ‰€ä»¥å®ƒçš„ <code>trylock</code> éœ€è¦å…ˆå°† <code>sem-&gt;count</code> èµ‹å€¼ç»™ <code>tmp</code>ï¼Œå†è‡ªå¢ <code>tmp</code> ï¼Œåˆ©ç”¨ <code>tmp</code> çš„å€¼è¿›è¡Œ CAS</p>
<pre><code class="language-C">/*
 * trylock for reading -- returns 1 if successful, 0 if contention
 */
static inline int __down_read_trylock(struct rw_semaphore *sem)
{
	__s32 result, tmp;
	__asm__ __volatile__(
		&quot;# beginning __down_read_trylock\n\t&quot;
		&quot;  movl      %0,%1\n\t&quot;
		&quot;1:\n\t&quot;
		&quot;  movl	     %1,%2\n\t&quot;
		&quot;  addl      %3,%2\n\t&quot;
		&quot;  jle	     2f\n\t&quot;
LOCK_PREFIX	&quot;  cmpxchgl  %2,%0\n\t&quot;
		&quot;  jnz	     1b\n\t&quot;
		&quot;2:\n\t&quot;
		&quot;# ending __down_read_trylock\n\t&quot;
		: &quot;+m&quot;(sem-&gt;count), &quot;=&amp;a&quot;(result), &quot;=&amp;r&quot;(tmp)
		: &quot;i&quot;(RWSEM_ACTIVE_READ_BIAS)
		: &quot;memory&quot;, &quot;cc&quot;);
	return result&gt;=0 ? 1 : 0;
}

/*
 * trylock for writing -- returns 1 if successful, 0 if contention
 */
static inline int __down_write_trylock(struct rw_semaphore *sem)
{
	signed long ret = cmpxchg(&amp;sem-&gt;count,
				  RWSEM_UNLOCKED_VALUE, 
				  RWSEM_ACTIVE_WRITE_BIAS);
	if (ret == RWSEM_UNLOCKED_VALUE)
		return 1;
	return 0;
}
</code></pre>
<p>downgrade_write çš„å®ç°åˆ™ç±»ä¼¼å†™é”è§£é”ï¼Œç„¶ååˆ¤æ–­æ˜¯å¦æœ‰å¿…è¦å”¤é†’ç­‰å¾…é˜Ÿåˆ—ä¸­çš„é¡¹ï¼Œè¿™é‡Œå…¶å®å’Œå†™é”è§£é”ï¼ˆ<code>up_write</code>ï¼‰çš„ä¸»è¦å·®åˆ«å°±æ˜¯ç»™ <code>sem-&gt;count</code> åŠ ä¸Šçš„åç§»é‡å°‘äº† 1ï¼ˆå¯ä»¥å›å»çœ‹å‰é¢å‡ ä¸ª <code>RWSEM_</code> å¼€å¤´çš„å®å®šä¹‰ï¼‰ï¼Œè€Œè¿™ä¸ª 1 å°±æ˜¯è¯»é”å çš„å€¼</p>
<pre><code class="language-C">/*
 * downgrade write lock to read lock
 */
static inline void __downgrade_write(struct rw_semaphore *sem)
{
	__asm__ __volatile__(
		&quot;# beginning __downgrade_write\n\t&quot;
LOCK_PREFIX	&quot;  addl      %[bias],(%%rdi)\n\t&quot; /* transitions 0xZZZZ0001 -&gt; 0xYYYY0001 */
		&quot;  js        2f\n\t&quot; /* jump if the lock is being waited upon */
		&quot;1:\n\t&quot;
		LOCK_SECTION_START(&quot;&quot;)
		&quot;2:\n\t&quot;
		&quot;  call	     rwsem_downgrade_thunk\n&quot;
		&quot;  jmp       1b\n&quot;
		LOCK_SECTION_END
		&quot;# ending __downgrade_write\n&quot;
		: &quot;=m&quot;(sem-&gt;count)
		: &quot;D&quot;(sem), [bias] &quot;i&quot;(-RWSEM_WAITING_BIAS), &quot;m&quot;(sem-&gt;count)
		: &quot;memory&quot;, &quot;cc&quot;);
}

/*
 * downgrade a write lock into a read lock
 * - caller incremented waiting part of count, and discovered it to be still negative
 * - just wake up any readers at the front of the queue
 */
struct rw_semaphore *rwsem_downgrade_wake(struct rw_semaphore *sem)
{
	rwsemtrace(sem,&quot;Entering rwsem_downgrade_wake&quot;);

	spin_lock(&amp;sem-&gt;wait_lock);

	/* do nothing if list empty */
	if (!list_empty(&amp;sem-&gt;wait_list))
		sem = __rwsem_do_wake(sem,0);

	spin_unlock(&amp;sem-&gt;wait_lock);

	rwsemtrace(sem,&quot;Leaving rwsem_downgrade_wake&quot;);
	return sem;
}
</code></pre>
<p>æ€»ç»“ä¸€ä¸‹ï¼Œè¯»/å†™ä¿¡å·é‡å’Œè¯»/å†™è‡ªæ—‹é”ç±»ä¼¼ï¼Œä¸¤è€…è¯­ä¹‰ä¸Šæ˜¯ç›¸åŒçš„ï¼Œä¹Ÿéƒ½æ˜¯è¯»ä¼˜å…ˆçš„ï¼Œåªä¸è¿‡ä¿¡å·é‡æ˜¯ç¡çœ é”ï¼Œå½“æœ‰é•¿æ—¶é—´è·å–ä¸åˆ°é”çš„æƒ…å†µæ—¶ï¼Œä¸ä¼šå¯¼è‡´è¿‡å¤šçš„ CPU å¼€é”€</p>
<h2 id="é¡ºåºé”">é¡ºåºé”</h2>
<p>é¡ºåºé”å’Œå‰é¢ä¸¤è€…æœ‰ä¸ªé‡è¦çš„åŒºåˆ«ï¼Œé¡ºåºé”æ˜¯<strong>å†™ä¼˜å…ˆ</strong>çš„ï¼Œè®©æˆ‘ä»¬æ¥åˆ†æä¸‹å®ƒæ˜¯å¦‚ä½•å®ç°çš„</p>
<p>é¦–å…ˆè¿˜æ˜¯ä½¿ç”¨æ–¹å¼ä¸Šï¼š</p>
<pre><code class="language-C">// å®šä¹‰ä¸€ä¸ªé¡ºåºé”
seqlock_t mr_seq_lock = DEFINE_SEQLOCK(mr_seq_lock);

write_seqlock(&amp;mr_seq_lock);
// è¯»å†™ä¸´ç•ŒåŒº
write_sequnlock(&amp;mr_seq_lock);

// è¯»é”çš„ä½¿ç”¨æœ‰è¾ƒå¤§åŒºåˆ«
unsigned long seq;
do {
	seq = read_seqbegin(&amp;mr_seq_lock);
  // è¯»å–æ•°æ®...
} while (read_seqretry(&amp;mr_seq_lock, seq));
</code></pre>
<p>ä¸€ä¸ªä½¿ç”¨ä¾‹å­æ˜¯å†…æ ¸çš„ jiffiesï¼Œå®ƒå­˜å‚¨äº†æœºå™¨å¯åŠ¨åˆ°å½“å‰çš„æ—¶é’ŸèŠ‚æ‹ï¼Œæ¯æ¬¡æ—¶é’Ÿä¸­æ–­æ—¶éƒ½ä¼šæ›´æ–°è¿™ä¸ªå€¼ï¼Œæ‰€ä»¥æ˜¯ä¸€ä¸ªé«˜é¢‘å†™å…¥çš„åœºæ™¯ï¼Œ<code>get_jiffies_64()</code> å‡½æ•°ç”¨æ¥è·å–è¿™ä¸ªå€¼ï¼Œå®ƒçš„å®ç°æ˜¯è¿™æ ·çš„</p>
<pre><code class="language-C">u64 get_jiffies_64(void)
{
	unsigned long seq;
	u64 ret;

	do {
		seq = read_seqbegin(&amp;xtime_lock);
		ret = jiffies_64;
	} while (read_seqretry(&amp;xtime_lock, seq));
	return ret;
}
</code></pre>
<p>é¡ºåºé”åœ¨è¯»å–æ—¶éœ€è¦ä¸€ä¸ªå¾ªç¯ï¼Œè¿™æ˜¯ä¸ºäº†åˆ¤æ–­åœ¨è¿™ä¸ªè¿‡ç¨‹ä¸­æ˜¯å¦æœ‰å‘ç”Ÿå†™å…¥ï¼Œå¦‚æœæ²¡æœ‰ï¼Œé‚£ä¹ˆè¯»å–å°±æ˜¯å®‰å…¨çš„ï¼Œå¦åˆ™éœ€è¦é‡è¯•</p>
<p>å®ç°ä¸Šï¼Œä»£ç ä½äº <a href="https://elixir.bootlin.com/linux/v2.6.0/source/include/linux/seqlock.h#L50">/include/linux/seqlock.h</a>ï¼Œæœ‰æ¯”è¾ƒæ¸…æ™°çš„æ³¨é‡Šï¼š</p>
<pre><code class="language-C">#define SEQLOCK_UNLOCKED { 0, SPIN_LOCK_UNLOCKED }
#define seqlock_init(x)	do { *(x) = (seqlock_t) SEQLOCK_UNLOCKED; } while (0)

/* Lock out other writers and update the count.
 * Acts like a normal spin_lock/unlock.
 * Don't need preempt_disable() because that is in the spin_lock already.
 */
static inline void write_seqlock(seqlock_t *sl)
{
	spin_lock(&amp;sl-&gt;lock);
	++sl-&gt;sequence;
	smp_wmb();			
}	

static inline void write_sequnlock(seqlock_t *sl) 
{
	smp_wmb();
	sl-&gt;sequence++;
	spin_unlock(&amp;sl-&gt;lock);
}

static inline int write_tryseqlock(seqlock_t *sl)
{
	int ret = spin_trylock(&amp;sl-&gt;lock);

	if (ret) {
		++sl-&gt;sequence;
		smp_wmb();			
	}
	return ret;
}

/* Start of read calculation -- fetch last complete writer token */
static inline unsigned read_seqbegin(const seqlock_t *sl)
{
	unsigned ret = sl-&gt;sequence;
	smp_rmb();
	return ret;
}

/* Test if reader processed invalid data.
 * If initial values is odd, 
 *	then writer had already started when section was entered
 * If sequence value changed
 *	then writer changed data while in section
 *    
 * Using xor saves one conditional branch.
 */
static inline int read_seqretry(const seqlock_t *sl, unsigned iv)
{
	smp_rmb();
	return (iv &amp; 1) | (sl-&gt;sequence ^ iv);
}
</code></pre>
<p>å¯ä»¥çœ‹åˆ°ï¼Œé¡ºåºé”æ˜¯åŸºäºä¸€ä¸ªè‡ªæ—‹é”å®ç°çš„ã€‚ä½†é¢å¤–ä¾èµ–ä¸€ä¸ªåºåˆ—è®¡æ•°å™¨ï¼Œå½“è·å–å†™é”æ—¶ï¼Œè¿™ä¸ªåºåˆ—å€¼ä¼šå¢åŠ ã€‚è¯»å–æ•°æ®æ—¶è¦å…ˆè°ƒç”¨ <code>read_seqbegin</code>ï¼Œå®ƒä¼šè¿”å›è¿™ä¸ªåºåˆ—å€¼ï¼Œè¯»å–å®Œæˆåé€šè¿‡ <code>read_seqretry</code> æ£€æŸ¥ä¼ å…¥çš„å€¼ <code>iv</code>ï¼Œæ»¡è¶³ä»¥ä¸‹ä¸¤ä¸ªæ¡ä»¶åˆ™è¯´æ˜è¯»æ˜¯å®‰å…¨çš„ï¼š</p>
<ul>
<li>å¦‚æœ <code>iv</code> æ˜¯å¶æ•°ï¼ˆåˆå§‹å€¼ä¸º 0ï¼Œå†™é”ä¼šåŠ  1ï¼‰åˆ™è¯´æ˜ä¸æ˜¯å¤„åœ¨ä¸€ä¸ªå†™æ“ä½œè¿›è¡Œçš„è¿‡ç¨‹ä¸­</li>
<li><code>iv</code> å’Œåºåˆ—å€¼ç›¸åŒï¼ˆç›¸åŒå€¼å¼‚æˆ–ç»“æœä¸º 0ï¼‰è¯´æ˜æ²¡æœ‰å†™æ“ä½œå‘ç”Ÿè¿‡</li>
</ul>
<p>è¿™ä¸¤è€…éƒ½æ»¡è¶³ï¼Œè¯»å–çš„å€¼å°±æ˜¯æœ‰æ•ˆçš„</p>
<p>æ‰€ä»¥ï¼Œé¡ºåºé”æ˜¯ä¸€ç§<strong>ä¹è§‚é”</strong>ï¼Œæ˜¯ä¸å­˜åœ¨ã€Œè¯»é”ã€çš„ï¼Œè€Œæ˜¯é€šè¿‡ç±»ä¼¼ç‰ˆæœ¬å·çš„æœºåˆ¶æ¥è¯»ï¼Œå› æ­¤åªè¦æ²¡æœ‰å…¶ä»–å†™è€…ï¼Œéšæ—¶éƒ½å¯ä»¥è·å–åˆ°å†™é”ï¼Œä»¥æ­¤å®ç°å†™ä¼˜å…ˆ</p>

            </div>

            <div class="not-by-ai">
              <img src="/media/images/not-by-ai-cn.svg"/>
              <img src="/media/images/not-by-ai-jp.svg"/>
              <img src="/media/images/not-by-ai-en.svg"/>
            </div>

            
              <div class="tag-container">
                
                  <a href="https://xxxuuu.me/tag/N8TJ_6EbX/" class="tag">
                    Linux
                  </a>
                
                  <a href="https://xxxuuu.me/tag/YAELBbV8at/" class="tag">
                    å†…æ ¸
                  </a>
                
              </div>
            
            
              <div class="next-post">
                <div class="next">ä¸‹ä¸€ç¯‡</div>
                <a href="https://xxxuuu.me/post/2023summary/">
                  <h3 class="post-title">
                    2023 å¹´åº¦æ€»ç»“
                  </h3>
                </a>
              </div>
            

            
            
              <div id="giscus" class="giscus">
                <script src="https://giscus.app/client.js" data-repo="xxxuuu/xxxuuu.github.io" data-repo-id="MDEwOlJlcG9zaXRvcnkxODQ3Mjk3Mjg=" data-category="Announcements"  data-category-id="DIC_kwDOCwLAgM4ChgWc" data-mapping="title"  data-strict="0"  data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-theme="preferred_color_scheme" data-lang="zh-CN" data-loading="lazy" crossorigin="anonymous" async></script>
              </div>
            
          </div>

          

<div class="post-toc animate__animated animate__fadeInUp">
  <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E8%AF%BB%E5%86%99%E8%87%AA%E6%97%8B%E9%94%81">è¯»/å†™è‡ªæ—‹é”</a></li>
<li><a href="#%E8%AF%BB%E5%86%99%E4%BF%A1%E5%8F%B7%E9%87%8F">è¯»/å†™ä¿¡å·é‡</a></li>
<li><a href="#%E9%A1%BA%E5%BA%8F%E9%94%81">é¡ºåºé”</a></li>
</ul>
</li>
</ul>

</div>


<script>
  let lastTop = 0, linkList = [], headList = [], postBody, lastIndex = -1;
  let activeClass = 'active-toc';
  let tocContent;

  function addActiveClass(index) {
    if (index >= 0 && index < linkList.length) {
      linkList[index].parentElement.classList.add(activeClass);
    }
  }

  function removeActiveClass(index) {
    if (index >= 0 && index < linkList.length) {
      linkList[index].parentElement.classList.remove(activeClass);
    }
  }

  function getElementTop (el) {
    let actualTop = el.offsetTop
    let current = el.offsetParent
    while (current !== null) {
      actualTop += current.offsetTop
      current = current.offsetParent
    }
    return actualTop
  }

  function syncActiveClass() {
    if (linkList.length <= 0) {
      return;
    }
    let scrollTop = document.scrollingElement.scrollTop;
    let eps = window.innerHeight;

    let current = 0, closestOffset = 0x3f3f3f3f, hasFind = false;
    for (let i = 0; i < headList.length; i++) {
      let offset = Math.abs(getElementTop(headList[i]) - scrollTop);
      if (offset > eps) {
        continue;
      }
      if (offset < closestOffset) {
        current = i;
        closestOffset = offset;
        hasFind = true;
      }
    }
    if(!hasFind) {
      return;
    }

    removeActiveClass(lastIndex)
    addActiveClass(current);
    lastIndex = current;
  }

  document.addEventListener('scroll', syncActiveClass);
  window.addEventListener('load', function () {
    tocContent = document.querySelector('.markdownIt-TOC');
    if (!tocContent) return;

    postBody = document.querySelector('.post-content');
    for (let i = 0; i < postBody.children.length; i++) {
      if (postBody.children[i].__proto__ === HTMLHeadingElement.prototype) {
        headList.push(postBody.children[i]);
      }
    }
    linkList = document.querySelectorAll('.post-toc a');

    setTimeout(function () {
      if ("createEvent" in document) {
        let evt = document.createEvent("HTMLEvents");
        evt.initEvent("scroll", false, true);
        document.dispatchEvent(evt);
      }
      else {
        document.fireEvent("scroll");
      }
    }, 500)
  })
</script>

        </div>
      </div>

      <footer class="footer animate__animated animate__flipInX">
  <div class="site-footer">
    <p></p>
    <p>Â© xÂ³uÂ³ Â· Powered by <a href="https://gridea.dev/">Gridea</a> & <a href="https://github.com/xxxuuu/gridea-theme-autumn">Autumn</a> | <a class="rss" href="https://xxxuuu.me/atom.xml" target="_blank">RSS</a></p>
  </div>
</footer>


    </div>

    <script type="application/javascript">

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>


  <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.4.0/build/highlight.min.js"></script>
  <script>
    window.onload = () => {
        hljs.highlightAll()
    }
  </script>


<script>
  const images = document.querySelectorAll('.post-content img');

  for (let i = 0; i < images.length; i++) {
    const img = images[i];

    const link = document.createElement('a');
    link.href = img.src;
    link.setAttribute("data-fancybox", "gallery");

    img.parentNode.insertBefore(link, img);
    link.appendChild(img);
  }
</script>




  </body>
</html>
