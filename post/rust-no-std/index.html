<!DOCTYPE html><html data-astro-cid-pjvcz6dw lang=zh-CN><head><meta charset=UTF-8><meta content="width=device-width,initial-scale=1" name=viewport><link href="https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F4cc04375-345a-4a1e-bdf0-3a7c88ef0425%2F49b4570c-b2f0-457b-81b7-b68e2693a471%2Favatar.png?table=collection&id=0bb2e606-8d0c-4f7c-aca9-70986e90c055" rel=icon><link href=https://xxxuuu.me/post/rust-no-std/ rel=canonical><link href=/rss/feed.xml rel=alternate title=x³u³ type=application/rss+xml><link href=/sitemap-index.xml rel=sitemap><title>译：使 Rust library 兼容 no_std | x³u³</title><meta content="Effective Rust Item 33" name=description><meta content=website property=og:type><meta content=https://xxxuuu.me/post/rust-no-std/ property=og:url><meta content="译：使 Rust library 兼容 no_std | x³u³" property=og:title><meta content="Effective Rust Item 33" property=og:description><meta content="https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F4cc04375-345a-4a1e-bdf0-3a7c88ef0425%2Fa9af1d6b-f284-4734-ba06-990353cf3f84%2FElaina.jpg?table=collection&id=0bb2e606-8d0c-4f7c-aca9-70986e90c055" property=og:image><meta content=summary_large_image name=twitter:card><meta content=@xxuuu0 name=twitter:site><meta content="译：使 Rust library 兼容 no_std | x³u³" name=twitter:title><meta content="Effective Rust Item 33" name=twitter:description><meta content="https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F4cc04375-345a-4a1e-bdf0-3a7c88ef0425%2Fa9af1d6b-f284-4734-ba06-990353cf3f84%2FElaina.jpg?table=collection&id=0bb2e606-8d0c-4f7c-aca9-70986e90c055" name=twitter:image><link href=https://cdn.jsdelivr.net/npm/photoswipe@5.4.3/dist/photoswipe.css rel=preload as=style onload="this.onload=null,this.rel=&#34;stylesheet&#34;"><noscript><link href=https://cdn.jsdelivr.net/npm/photoswipe@5.4.3/dist/photoswipe.css rel=stylesheet></noscript><script>!function(){const e=localStorage.getItem("theme")||(window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light");document.documentElement.classList.add(e)}()</script><link href=/_astro/katex.CVb4srxQ.css rel=stylesheet><link href=/_astro/_slug_.DXL8v6Xi.css rel=stylesheet><link href=/_astro/_slug_.BzJEnS8p.css rel=stylesheet><link href=/_astro/_slug_.DOIB7y8p.css rel=stylesheet><script src=/_astro/hoisted.B871fABB.js type=module></script></head><body data-astro-cid-pjvcz6dw><header class=notion-header data-astro-cid-4f4rmh32><div class=header-container data-astro-cid-4f4rmh32><div class=header-content data-astro-cid-4f4rmh32><div class=logo data-astro-cid-4f4rmh32><a href=/ class=logo-link data-astro-cid-4f4rmh32>x³u³</a></div><div class=header-actions data-astro-cid-4f4rmh32><nav class=nav data-astro-cid-4f4rmh32><a href=/ class=nav-link data-astro-cid-4f4rmh32>🏠 首页 </a><a href=/archive class=nav-link data-astro-cid-4f4rmh32>📃 归档 </a><a href=/links class=nav-link data-astro-cid-4f4rmh32>👬 友链 </a><a href=https://p.xxxuuu.me rel="noopener noreferrer" target=_blank class=nav-link data-astro-cid-4f4rmh32>📷 摄影 <span class=external-icon data-astro-cid-4f4rmh32>↗</span> </a><a href=/about class=nav-link data-astro-cid-4f4rmh32>👤 关于</a></nav><button aria-label="Toggle theme" title=切换主题 data-astro-cid-44mn2ykx id=theme-toggle><svg fill=none viewBox="0 0 24 24" height=20 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=20 class=sun-icon data-astro-cid-44mn2ykx xmlns=http://www.w3.org/2000/svg><circle cx=12 cy=12 data-astro-cid-44mn2ykx r=5></circle><line data-astro-cid-44mn2ykx x1=12 x2=12 y1=1 y2=3></line><line data-astro-cid-44mn2ykx x1=12 x2=12 y1=21 y2=23></line><line data-astro-cid-44mn2ykx x1=4.22 x2=5.64 y1=4.22 y2=5.64></line><line data-astro-cid-44mn2ykx x1=18.36 x2=19.78 y1=18.36 y2=19.78></line><line data-astro-cid-44mn2ykx x1=1 x2=3 y1=12 y2=12></line><line data-astro-cid-44mn2ykx x1=21 x2=23 y1=12 y2=12></line><line data-astro-cid-44mn2ykx x1=4.22 x2=5.64 y1=19.78 y2=18.36></line><line data-astro-cid-44mn2ykx x1=18.36 x2=19.78 y1=5.64 y2=4.22></line></svg> <svg fill=none viewBox="0 0 24 24" height=20 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=20 class=moon-icon data-astro-cid-44mn2ykx xmlns=http://www.w3.org/2000/svg><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z" data-astro-cid-44mn2ykx></path></svg></button></div></div></div></header><main class=notion-main data-astro-cid-pjvcz6dw><article class=content data-astro-cid-gbhzkc2y><div class=notion-page data-astro-cid-gbhzkc2y><div class=page-container data-astro-cid-gbhzkc2y><div class=page-main data-astro-cid-gbhzkc2y><header class=page-header data-astro-cid-gbhzkc2y><h1 class=page-title data-astro-cid-gbhzkc2y>译：使 Rust library 兼容 no_std</h1></header><div class=page-meta data-astro-cid-gbhzkc2y><div class=meta-info data-astro-cid-gbhzkc2y><span class=meta-item data-astro-cid-gbhzkc2y><span class=meta-icon data-astro-cid-gbhzkc2y>📅</span> <time data-astro-cid-gbhzkc2y datetime=2024-09-21>2024年09月21日</time> </span><span class=meta-item data-astro-cid-gbhzkc2y><span class=meta-icon data-astro-cid-gbhzkc2y>⏱️</span> <span data-astro-cid-gbhzkc2y>8 分钟阅读</span></span></div><div class=meta-tags data-astro-cid-gbhzkc2y><span class=tags-icon data-astro-cid-gbhzkc2y>🏷️</span> <a href=/tag/rust class=tag-pill data-astro-cid-gbhzkc2y>Rust</a></div><div class=meta-description data-astro-cid-gbhzkc2y>Effective Rust Item 33</div></div><hr class=page-divider data-astro-cid-gbhzkc2y><div class=notion-content data-astro-cid-gbhzkc2y><blockquote class=notion-quote>原文为 <a href=https://www.lurklurk.org/effective-rust/no-std.html rel="noopener noreferrer" target=_blank>Effective Rust 第 33 条</a>，笔者将其翻译后提交至 <a href=https://rustx-labs.github.io/effective-rust-cn/chapter_6/item33-no-std.html rel="noopener noreferrer" target=_blank>Effective Rust 中文版</a>，同步转载至此处</blockquote><p><br></p><p>Rust 附带一个名为 <code>std</code> 的标准库，其中包含了从标准数据结构到网络，从多线程支持到文件 I/O 等用于各种常见任务的代码。为了方便使用， <code>std</code> 中的一些项目会通过 <a href=https://doc.rust-lang.org/std/prelude/index.html rel="noopener noreferrer" target=_blank>prelude</a> 自动导入到你的程序中，<a href=https://doc.rust-lang.org/std/prelude/index.html rel="noopener noreferrer" target=_blank>prelude</a> 是一组 <code>use</code> 语句，可以在不需要指定完整名称的情况下直接使用这些常见类型（例如使用 <code>Vec</code> 而不是 <code>std::vec::Vec</code>）。</p><p>Rust 还支持为无法提供完整标准库的环境构建代码，如引导加载程序、固件或一般的嵌入式平台。通过在 <code>src/lib.rs</code> 文件顶部添加 <code>#![no_std]</code> 属性，可以指示 crate 在这类受限环境中编译。</p><p><br></p><p>本节将探讨在 <code>no_std</code> 环境中编译时我们会失去哪些功能，以及仍然可用的库函数。我们会发现，即使在这种受限环境中，依然有相当多的功能可供使用。</p><p>不过，这里特别关注的是针对<em>库</em>代码的 <code>no_std</code> 支持。构建 <code>no_std</code> <em>可执行</em>文件的复杂性超出了本文的范围<code class=notion-equation>\textcolor{gray}{^1}</code>，因此本节重点是对那些不得不在如此极简环境中工作的可怜人来说，如何确保库代码是可用的。</p><p><br></p><h2 id=core><code>core</code></h2><p>即使在为最受限的平台构建时，标准库中的许多基本类型也仍然可用。例如 <code><a href=https://doc.rust-lang.org/core/option/enum.Option.html rel="noopener noreferrer" target=_blank>Option</a></code> 和 <code><a href=https://doc.rust-lang.org/core/result/enum.Result.html rel="noopener noreferrer" target=_blank>Result</a></code> 以及各种 <code><a href=https://doc.rust-lang.org/core/iter/trait.Iterator.html rel="noopener noreferrer" target=_blank>Iterator</a></code>，尽管它们名称不同。</p><p>这些基本类型的不同名称以 <code>core::</code> 开头，表明它们来自 <code>core</code> 库，这是一个即使在大多数 <code>no_std</code> 环境中也可用的标准库。这些 <code>core::</code> 类型的行为与等效的 <code>std::</code> 类型完全相同，因为它们实际上是同个类型 —— 对应的 <code>std::</code> 版本都只是底层 <code>core::</code> 类型的重新导出。</p><p>这意味着有一种快速而肮脏的方法来判断某个 <code>std::</code> 项目在 <code>no_std</code> 环境中是否可用： 访问 <code><a href=https://doc.rust-lang.org/std/index.html rel="noopener noreferrer" target=_blank>doc.rust-lang.org</a></code> 并找到感兴趣的 <code>std</code> 项目，点击 “soure”（在右上角）<code class=notion-equation>\textcolor{gray}{^2}</code>，如果它跳转到了 <code>src/core/...</code> 中，则说明该项可通过 <code>core::</code> 在 <code>no_std</code> 下使用。</p><p>正常情况下 <code>core</code> 中的类型可自动用于所有 Rust 程序。但在 <code>no_std</code> 环境需要显式 <code>use</code>，因为此时没有 <code>std</code> <a href=https://doc.rust-lang.org/std/prelude/index.html rel="noopener noreferrer" target=_blank>prelude</a> 帮忙导入。</p><p><br></p><p>实际中，对于许多环境（甚至是 <code>no_std</code>）来说，纯粹依赖 <code>core</code> 会有很大的限制，因为 <code>core</code> 的一个核心（双关语）约束是它不会进行堆分配。</p><p>虽然 Rust 很擅长将数据放入栈中并安全地跟踪其相应的生命周期（<a href=https://rustx-labs.github.io/effective-rust-cn/chapter_3/item14-lifetimes.html rel="noopener noreferrer" target=_blank>第 14 条</a>），但 <code>core</code> 的这种限制仍然意味着无法提供标准数据结构（vector, map, set），因为它们都需要分配堆空间来存放内部元素。所以这个限制也大大减少了在此环境中可用的 crate 数量。</p><p><br></p><h2 id=alloc><code>alloc</code></h2><p>但如果所在的 <code>no_std</code> 环境<em>的确</em>支持堆分配，则 <code>std</code> 中的许多标准数据结构仍然可用。这些数据结构以及其他使用分配功能的部分被分组到 Rust 的 <code><a href=https://doc.rust-lang.org/alloc/ rel="noopener noreferrer" target=_blank>alloc</a></code> 库中。</p><p>和 <code>core</code> 一样，这些 <code>alloc</code> 变体实际上在底层是相同的类型。例如 <code>std::vec::Vec</code> 的真实名称是 <code>alloc::vec::Vec</code>。</p><p>如果 <code>no_std</code> 的 crate 要使用 <code>alloc</code>，需要在 <code>src/lib.rs</code> 额外显式声明 <code>extern crate alloc;</code><code class=notion-equation>\textcolor{gray}{^3}</code>：</p><div class=notion-code-block><div class=notion-code-header><span class=notion-code-language>Rust</span> <button aria-label=复制代码 title=复制代码 class=notion-code-copy><svg fill=none viewBox="0 0 24 24" height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16><rect height=13 rx=2 ry=2 width=13 x=9 y=9></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg> <span class=copy-text>COPY</span></button></div><pre class=notion-code><code class=language-rust>//! 我的 `no_std` 兼容 crate.
#![no_std]

// 引入 `alloc`.
extern crate alloc;
</code></pre></div><p>引入 <code>alloc</code> 库可以启用许多我们熟悉的朋友，现在他们以真实的名称被称呼：</p><ul><li><code><a href=https://doc.rust-lang.org/alloc/boxed/struct.Box.html rel="noopener noreferrer" target=_blank>alloc::boxed::Box&lt;T&gt;</a></code></li><li><code><a href=https://doc.rust-lang.org/alloc/rc/struct.Rc.html rel="noopener noreferrer" target=_blank>alloc::rc::Rc&lt;T&gt;</a></code></li><li><code><a href=https://doc.rust-lang.org/alloc/sync/struct.Arc.html rel="noopener noreferrer" target=_blank>alloc::sync::Arc&lt;T&gt;</a></code></li><li><code><a href=https://doc.rust-lang.org/alloc/vec/struct.Vec.html rel="noopener noreferrer" target=_blank>alloc::vec::Vec&lt;T&gt;</a></code></li><li><code><a href=https://doc.rust-lang.org/alloc/string/struct.String.html rel="noopener noreferrer" target=_blank>alloc::string::String</a></code></li><li><code><a href=https://doc.rust-lang.org/alloc/macro.format.html rel="noopener noreferrer" target=_blank>alloc::format!</a></code></li><li><code><a href=https://doc.rust-lang.org/alloc/collections/btree_map/struct.BTreeMap.html rel="noopener noreferrer" target=_blank>alloc::collections::BTreeMap&lt;K, V&gt;</a></code></li><li><code><a href=https://doc.rust-lang.org/alloc/collections/btree_set/struct.BTreeSet.html rel="noopener noreferrer" target=_blank>alloc::collections::BTreeSet&lt;T&gt;</a></code></li></ul><p>有了这些朋友，许多 crate 就可以兼容 <code>no_std</code> —— 前提是不涉及 I/O 或网络。</p><p><br></p><p>但 <code>alloc</code> 提供的数据结构显然还缺少了两个集合 —— <code><a href=https://doc.rust-lang.org/std/collections/struct.HashMap.html rel="noopener noreferrer" target=_blank>HashMap</a></code> 和 <code><a href=https://doc.rust-lang.org/std/collections/hash_set/struct.HashSet.html rel="noopener noreferrer" target=_blank>HashSet</a></code>，它们特定于 <code>std</code> 而不是 <code>alloc</code>。这是因为这些基于 hash 的容器依靠随机种子来防止 hash 冲突攻击，但安全的随机数生成需要依赖操作系统的帮助，而 <code>alloc</code> 不能假设操作系统存在。</p><p>另一个缺失的部分是同步功能，例如 <code><a href=https://doc.rust-lang.org/std/sync/struct.Mutex.html rel="noopener noreferrer" target=_blank>std::sync::Mutex</a></code>，这是多线程代码所必需的，但这些类型同样特定于 <code>std</code>，它们依赖操作系统的同步原语，如果没有操作系统，这些同步原语也将不可用。在 <code>no_std</code> 下编写多线程代码，第三方 crate 可能是唯一选择，例如 <code><a href=https://docs.rs/spin/ rel="noopener noreferrer" target=_blank>spin</a></code>。</p><p><br></p><h2 id=-no_std->为 <code>no_std</code> 编写代码</h2><p>前文已经指出，对于<em>某些</em> crate 库，要使代码兼容 <code>no_std</code> 只需要以下修改：</p><ul><li>用相同的 <code>core::</code> 或 <code>alloc::</code> crate 替换 <code>std::</code> 类型（由于缺少 <code>std</code> prelude，还需要 <code>use</code> 完整的类型名称）</li><li>将 <code>HashMap</code> / <code>HashSet</code> 迁移为 <code>BTreeMap</code> / <code>BTreeSet</code></li></ul><p>但这些操作只有在依赖的所有 crate（<a href=https://rustx-labs.github.io/effective-rust-cn/chapter_4/item25-dep-graph.html rel="noopener noreferrer" target=_blank>第 25 条</a>）也兼容 <code>no_std</code> 时才有意义 —— 如果使用您 crate 的用户被迫链接到任何 <code>std</code> 中，与 <code>no_std</code> 的兼容就会失去意义。</p><p><br></p><p>这里还有一个问题：Rust 编译器并不会告诉你一个 <code>no_std</code> crate 中是否有引入使用了 <code>std</code> 的依赖。这意味着只要添加或更新一个使用了 <code>std</code> 的依赖，就能轻松破坏掉 <code>no_std</code> crate 的兼容性。</p><p>为了避免这个情况，<strong>请为 </strong><code><strong>no_std</strong></code><strong> 构建添加 CI 检查</strong>，以便 CI 系统（<a href=https://rustx-labs.github.io/effective-rust-cn/chapter_5/item32-ci.html rel="noopener noreferrer" target=_blank>第 32 条</a>）能在这种情况发生时发出警告。Rust 工具链支持开箱即用的交叉编译，因此只需为不支持 <code>std</code> 的目标系统（例如 <code>--target thumbv6m-none-eabi</code>）执行<a href=https://www.reddit.com/r/rust/comments/ef8nd9/how_to_avoid_accidentally_breaking_no_std/fbyz6ix/ rel="noopener noreferrer" target=_blank>交叉编译</a>，任何无意中依赖 <code>std</code> 的代码就会在此时编译失败。</p><p><br></p><p>所以，如果依赖项都支持，并且上面的简单修改就够了的话，不妨<strong>考虑让库代码兼容 </strong><code><strong>no_std</strong></code>。这不需要太多额外工作，却能让库有更广泛的适用性。</p><p>如果这些转换并<em>没有</em>覆盖 crate 中的所有代码，但未覆盖的只是代码中的一小部分或包装良好的部分，那么可以考虑向 crate 添加一个 feature （<a href=https://rustx-labs.github.io/effective-rust-cn/chapter_4/item26-features.html rel="noopener noreferrer" target=_blank>第 26 条</a>）以控制是否启用这部分代码。</p><p>这种允许使用 <code>std</code> 特定功能的 feature ，通常会将其命名为 <code>std</code>：</p><div class=notion-code-block><div class=notion-code-header><span class=notion-code-language>Rust</span> <button aria-label=复制代码 title=复制代码 class=notion-code-copy><svg fill=none viewBox="0 0 24 24" height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16><rect height=13 rx=2 ry=2 width=13 x=9 y=9></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg> <span class=copy-text>COPY</span></button></div><pre class=notion-code><code class=language-rust>#![cfg_attr(not(feature = &quot;std&quot;), no_std)]</code></pre></div><p>或是将控制是否启用了 <code>alloc</code> 派生功能的 feature 命名为 <code>alloc</code>：</p><div class=notion-code-block><div class=notion-code-header><span class=notion-code-language>Rust</span> <button aria-label=复制代码 title=复制代码 class=notion-code-copy><svg fill=none viewBox="0 0 24 24" height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16><rect height=13 rx=2 ry=2 width=13 x=9 y=9></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg> <span class=copy-text>COPY</span></button></div><pre class=notion-code><code class=language-rust>#[cfg(feature = &quot;alloc&quot;)]
extern crate alloc;</code></pre></div><p>注意，设计这类 feature 时有个容易忽视的陷阱：不要设置一个 <code>no_std</code> feature 来<em>禁用</em>需要 <code>std</code> 的功能（或类似的 <code>no_alloc</code> feature），正如<a href=https://rustx-labs.github.io/effective-rust-cn/chapter_4/item26-features.html rel="noopener noreferrer" target=_blank>第 26 条</a>中提到的，feature 应当是可累加的，这样做会导致无法将启用了 <code>no_std</code> 和没有启用的两个 crate 用户组合在一起 —— 前者会删除后者所依赖的代码。</p><p>和所有带有 feautre 门控的代码一样，确保你的 CI 系统（<a href=https://rustx-labs.github.io/effective-rust-cn/chapter_5/item32-ci.html rel="noopener noreferrer" target=_blank>第 32 条</a>）构建了所有相关的组合 —— 包括在 <code>no_std</code> 平台上关闭 <code>std</code> 特性的构建。</p><p><br></p><h2 id=fallible-allocation>可错分配（Fallible Allocation）</h2><p>前面考虑了两种不同的 <code>no_std</code> 环境：不允许堆分配的完全嵌入式的环境（<code>core</code>）和允许堆分配的更宽松的环境（<code>core</code> + <code>alloc</code>）。</p><p>然而，有一些重要的环境介于两者之间，特别是那些允许堆分配但可能会失败的环境，因为堆空间是有限的。</p><p>不幸的是，Rust 的标准 <code>alloc</code> 库假设堆分配不会失败，但这个假设并不总是成立。</p><p>即使简单地使用 <code>alloc::vec::Vec</code>，也可能在每一行代码中都触发分配：</p><div class=notion-code-block><div class=notion-code-header><span class=notion-code-language>Rust</span> <button aria-label=复制代码 title=复制代码 class=notion-code-copy><svg fill=none viewBox="0 0 24 24" height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16><rect height=13 rx=2 ry=2 width=13 x=9 y=9></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg> <span class=copy-text>COPY</span></button></div><pre class=notion-code><code class=language-rust>let mut v = Vec::new();
v.push(1); // 可能会分配
v.push(2); // 可能会分配
v.push(3); // 可能会分配
v.push(4); // 可能会分配</code></pre></div><p>这些操作都不会返回 <code>Result</code>，当这些分配失败了，会发生什么？</p><p>答案取决于工具链、目标平台和<a href=https://doc.rust-lang.org/std/alloc/fn.set_alloc_error_hook.html rel="noopener noreferrer" target=_blank>配置</a>，但很可能会导致 <code>panic!</code> 和程序终止。这里无法通过某种方式处理第 3 行的分配失败，并让程序继续执行第 4 行。</p><p><br></p><p>这种<em>可靠分配</em>（infallible allocation）的假设简化了在“正常”用户空间中运行的代码，因为在这些环境中，内存几乎是无限的 —— 或者内存耗尽意味着计算机本身出现了更严重的问题。</p><p>但可靠分配不适用于内存有限且程序必须应对内存不足的环境。这是一个在一些较老、内存安全性较差的语言中反而有更好支持的（罕见）领域：</p><ul><li>C 的级别足够低，分配是手动的，因此可以检查 <code>malloc</code> 的返回值是否为 <code>NULL</code>。</li><li>C++ 可以使用异常机制，捕获以 <code><a href=https://en.cppreference.com/w/cpp/memory/new/bad_alloc rel="noopener noreferrer" target=_blank>std::bad_alloc</a></code> 异常形式出现的分配失败<code class=notion-equation>\textcolor{gray}{^4}</code>。</li></ul><p>历史上，Rust 标准库无法处理分配失败的问题在一些备受瞩目的场合（如 <a href=https://lkml.org/lkml/2021/4/14/1099 rel="noopener noreferrer" target=_blank>Linux 内核</a>、Android 和 <a href=https://github.com/hyperium/hyper/issues/2265#issuecomment-693194229 rel="noopener noreferrer" target=_blank>Curl 工具</a>）中被指出，因此修复这一缺陷的工作正在进行中。</p><p><br></p><p>第一个尝试是<a href=https://github.com/rust-lang/rfcs/pull/2116 rel="noopener noreferrer" target=_blank>添加“可错的集合分配”</a>，它为许多涉及分配的集合 API 添加了允许可错分配的替代实现，通常是添加一个会返回 <code>Result&lt;_, AllocError&gt;</code> 的 <code>try_&lt;operation&gt;</code> 操作，例如：</p><ul><li><code><a href=https://doc.rust-lang.org/std/vec/struct.Vec.html#method.try_reserve rel="noopener noreferrer" target=_blank>Vec::try_reserve</a></code> 作为 <code><a href=https://doc.rust-lang.org/std/vec/struct.Vec.html#method.reserve rel="noopener noreferrer" target=_blank>Vec::reserve</a></code> 的替代品</li><li><code><a href=https://doc.rust-lang.org/std/boxed/struct.Box.html#method.try_new rel="noopener noreferrer" target=_blank>Box::try_new</a></code> 作为 <code><a href=https://doc.rust-lang.org/std/boxed/struct.Box.html#method.new rel="noopener noreferrer" target=_blank>Box::new</a></code> 的替代品（在 nightly toolchain 中可用）</li></ul><p>但这些允许可错分配的 API 功能也仅限于此。例如，（目前为止）还没有与 <code>Vec::push</code> 等效的可错分配版本，因此编写组装 vector 的代码时，可能需要进行精确计算，以确保不会发生内存分配错误。</p><div class=notion-code-block><div class=notion-code-header><span class=notion-code-language>Rust</span> <button aria-label=复制代码 title=复制代码 class=notion-code-copy><svg fill=none viewBox="0 0 24 24" height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16><rect height=13 rx=2 ry=2 width=13 x=9 y=9></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg> <span class=copy-text>COPY</span></button></div><pre class=notion-code><code class=language-rust>fn try_build_a_vec() -&gt; Result&lt;Vec&lt;u8&gt;, String&gt; {
    let mut v = Vec::new();

    // 仔细计算一下需要多少空间,这里简化为：
    let required_size = 4;

    v.try_reserve(required_size)
        .map_err(|_e| format!(&quot;Failed to allocate {} items!&quot;, required_size))?;

    // 我们现在知道这是安全的了
    v.push(1);
    v.push(2);
    v.push(3);
    v.push(4);

    Ok(v)
}</code></pre></div><p>除了增加允许可错分配的入口外，还可以通过关闭默认开启的 <code><a href=https://github.com/rust-lang/rust/pull/84266 rel="noopener noreferrer" target=_blank>no_global_oom_handling</a></code> 配置来禁用<em>可靠</em>分配操作。在堆内存有限的环境（如 Linux 内核）中，可以显式禁用此标志，以确保不会在代码中无意使用了可靠分配。</p><p><br></p><h2 id="">要记住的事</h2><ul><li><code>std</code> crate 中的许多项目实际上来自 <code>core</code> 或 <code>alloc</code>。</li><li>因此，使库代码兼容 <code>no_std</code> 可能比您想象的更简单。</li><li>通过在 CI 中检查 <code>no_std</code> 代码来确认 <code>no_std</code> 代码保持 <code>no_std</code> 兼容。</li><li>注意，当前支持在有限堆环境中工作的库十分有限。</li></ul><p><br></p><h3 id="">注释</h3><ol><li>有关创建 <code>no_std</code> 可执行文件所涉及的内容，请参阅 <a href=https://docs.rust-embedded.org/embedonomicon/ rel="noopener noreferrer" target=_blank>The Embedonomicon</a> 或 Philipp Opperamann 的<a href=https://os.phil-opp.com/freestanding-rust-binary/ rel="noopener noreferrer" target=_blank>早期博客文章</a>。</li><li>注意，该方法不一定正确。例如在撰写本文时，<code>Error</code> trait 在 <code>[core::]</code> 中定义，但被标记为不稳定（unstable），只有 <code><a href=https://doc.rust-lang.org/1.70.0/std/error/trait.Error.html rel="noopener noreferrer" target=_blank>std::</a></code><a href=https://doc.rust-lang.org/1.70.0/std/error/trait.Error.html rel="noopener noreferrer" target=_blank> 版本</a>是稳定的（stable）</li><li>在 Rust 2018 之前，<code>extern crate</code> 声明用来引入依赖项。现在这些依赖完全由 <code>Cargo.toml</code> 处理，但仍使用 <code>extern crate</code> 机制引入那些 <code>no_std</code> 环境中 Rust 标准库的可选部分（即 <em><a href=https://doc.rust-lang.org/edition-guide/rust-2018/path-changes.html#an-exception rel="noopener noreferrer" target=_blank>sysroot crates</a></em>）。</li><li>还可以为 <code>new</code> 调用添加 <code><a href=https://en.cppreference.com/w/cpp/memory/new/nothrow rel="noopener noreferrer" target=_blank>std::nothrow</a></code> 重载，并检查是否返回 <code>nullptr</code>。但一些容器方法比如 <code><a href=https://en.cppreference.com/w/cpp/container/vector/push_back rel="noopener noreferrer" target=_blank>vector&lt;T&gt;::push_back</a></code>，在内部进行分配，因此只能通过抛出异常来表示分配失败。</li></ol><p><br></p></div><nav class=post-navigation data-astro-cid-gbhzkc2y><a href=/post/infra-dilemma class="nav-link nav-prev" data-astro-cid-gbhzkc2y><span class=nav-label data-astro-cid-gbhzkc2y>← 上一篇</span> <span class=nav-title data-astro-cid-gbhzkc2y>Infra 窘境</span> </a><a href=/post/pve-migration-rescue class="nav-link nav-next" data-astro-cid-gbhzkc2y><span class=nav-label data-astro-cid-gbhzkc2y>下一篇 →</span> <span class=nav-title data-astro-cid-gbhzkc2y>PVE 迁移翻车自救</span></a></nav><footer class=page-footer data-astro-cid-gbhzkc2y><a href=/ class=back-link data-astro-cid-gbhzkc2y>← 返回首页</a></footer><section class=comments-section data-astro-cid-gbhzkc2y><div class=comments-container data-astro-cid-te6ksoa6 data-giscus-config="{&#34;slug&#34;:&#34;rust-no-std&#34;,&#34;title&#34;:&#34;译：使 Rust library 兼容 no_std&#34;,&#34;config&#34;:{&#34;repo&#34;:&#34;xxxuuu/xxxuuu.github.io&#34;,&#34;repoId&#34;:&#34;MDEwOlJlcG9zaXRvcnkxODQ3Mjk3Mjg&#34;,&#34;category&#34;:&#34;Announcements&#34;,&#34;categoryId&#34;:&#34;DIC_kwDOCwLAgM4ChgWc&#34;,&#34;mapping&#34;:&#34;title&#34;,&#34;strict&#34;:&#34;0&#34;,&#34;reactionsEnabled&#34;:&#34;1&#34;,&#34;emitMetadata&#34;:&#34;0&#34;,&#34;inputPosition&#34;:&#34;bottom&#34;,&#34;lang&#34;:&#34;zh-CN&#34;,&#34;lazy&#34;:true}}" data-provider=giscus id=comments><div class=comments-loading data-astro-cid-te6ksoa6>加载评论中...</div></div></section></div><aside class=toc-container data-astro-cid-gbhzkc2y><div class=toc-wrapper data-astro-cid-gbhzkc2y><div class=toc-title data-astro-cid-gbhzkc2y>目录</div><nav class=toc-nav data-astro-cid-gbhzkc2y></nav></div></aside></div></div></article></main><footer data-astro-cid-aoh3bln3><div class=container data-astro-cid-aoh3bln3><div class=footer-content data-astro-cid-aoh3bln3><div class=copyright data-astro-cid-aoh3bln3><p data-astro-cid-aoh3bln3>&copy; 2026 x³u³. All rights reserved.</p><p data-astro-cid-aoh3bln3 class=powered-by>Powered by <a href=https://github.com/xxxuuu/nopress rel="noopener noreferrer" target=_blank data-astro-cid-aoh3bln3>Nopress</a></p></div><div class=social-links data-astro-cid-aoh3bln3><a href=https://github.com/xxxuuu rel="noopener noreferrer" target=_blank class=social-icon aria-label=github data-astro-cid-aoh3bln3><span class=icon-wrapper data-astro-cid-aoh3bln3><svg fill=currentColor viewBox="0 0 24 24" aria-hidden=true><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/></svg></span></a><a href=https://x.com/xxuuu0 rel="noopener noreferrer" target=_blank class=social-icon aria-label=twitter data-astro-cid-aoh3bln3><span class=icon-wrapper data-astro-cid-aoh3bln3><svg fill=currentColor viewBox="0 0 24 24" aria-hidden=true><path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/></svg></span></a><a href=mailto:xxuuu0@outlook.com rel="noopener noreferrer" target=_blank class=social-icon aria-label=email data-astro-cid-aoh3bln3><span class=icon-wrapper data-astro-cid-aoh3bln3><svg fill=currentColor viewBox="0 0 24 24" aria-hidden=true><path d="M20 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 4-8 5-8-5V6l8 5 8-5v2z"/></svg></span></a><a href=/rss/feed.xml class="social-icon rss" aria-label=RSS订阅 data-astro-cid-aoh3bln3><span class=icon-wrapper data-astro-cid-aoh3bln3><svg fill=currentColor viewBox="0 0 24 24" aria-hidden=true><path d="M6.18 15.64a2.18 2.18 0 0 1 2.18 2.18C8.36 19 7.38 20 6.18 20C5 20 4 19 4 17.82a2.18 2.18 0 0 1 2.18-2.18M4 4.44A15.56 15.56 0 0 1 19.56 20h-2.83A12.73 12.73 0 0 0 4 7.27V4.44m0 5.66a9.9 9.9 0 0 1 9.9 9.9h-2.83A7.07 7.07 0 0 0 4 12.93V10.1z"/></svg></span></a></div></div></div></footer></body></html>